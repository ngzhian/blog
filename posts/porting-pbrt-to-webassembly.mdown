---
title: Porting PBRT to WebAssembly
date: 2020-06-13 13:00
...

# Porting to WebAssembly

This is a log of steps to port [pbrt](https://github.com/mmp/pbrt-v3) to Wasm.

I tried to keep the changes to pbrt as minimal as possible. This requires some hacking in git
submodules, which I will extract as diffs here, and also hacking in the CMakeLists.txt.
^[Ideally the submodule versions should be upgraded,
but I'm not familiar with the changes the authors made (the submodules are all forked versions of
the upstream). Also the CMake version is quite old, so I'll be doing some hacks that won't be
necessary or look very different if CMake version used was upgraded].

## Clone and setup env

Set up Emscripten using emsdk:

```
git clone https://github.com/emscripten-core/emsdk
cd emsdk
./emsdk install latest
./emsdk activate latest
source emsdk_env.sh
```

Clone pbrt:

```
git clone --recursive https://github.com/mmp/pbrt-v3/
cd pbrt-v3
```

The rest of the commands will assume you are in `pbrt-v3/`.

## Emcmake and emmake

Emscripten provides [wrappers](https://emscripten.org/docs/compiling/Building-Projects.html) around
`cmake` and `make`, these will set the variables defining the C++ compiler to the right values
so that we can target Wasm.

```
# create a folder for build outputs
mkdir wasm-build 
cd wasm-build
emcmake cmake ..
emmake make -j
```

## Pthreads

Here we hit our first error:

```
wasm-ld: error: 'atomics' feature is used by CMakeFiles/eLut.dir/eLut.cpp.o, so --shared-memory must
be used
em++: error: '/Users/ngzhian/src/emsdk/upstream/bin/wasm-ld -o
/var/folders/1n/02brqmc95d51bdrmzz8hhmrc0000gn/T/emscripten_temp_j5v5tu4f/eLut.wasm
CMakeFiles/eLut.dir/eLut.cpp.o -L/Users/ngzhian/src/emsdk/upstream/emscripten/system/local/lib
-L/Users/ngzhian/src/emsdk/upstream/emscripten/system/lib
-L/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libc.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libcompiler_rt.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libc-wasm.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libc++-noexcept.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libc++abi-noexcept.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libdlmalloc.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libpthread_stub.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libc_rt_wasm.a
/Users/ngzhian/src/emsdk/upstream/emscripten/cache/wasm/libsockets.a -mllvm
-combiner-global-alias-analysis=false -mllvm -enable-emscripten-sjlj -mllvm -disable-lsr
--allow-undefined --import-memory --import-table --strip-debug --export main --export malloc
--export free --export __data_end --export __wasm_call_ctors --export __errno_location -z
stack-size=5242880 --initial-memory=16777216 --no-entry --max-memory=16777216 --global-base=1024'
failed (1)
```

This error tells us that `eLut` was using [pthreads][], but we did not pass `-s USE_PTHREADS=1` when
compiling and linking.

The easiest way to fix this is to use `CMAKE_CXX_FLAGS`. For now we hack it inside of the check that
the compiler is Clang, since Emscripten uses Clang. ^[If a newer Cmake version was used, we can use
[`target_compile_options`][].]

```
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1a7fef9..bba4da2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -75,6 +75,8 @@ IF(CMAKE_COMPILER_IS_GNUCXX)
 ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
   SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
   SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-deprecated-register")
+  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -s USE_PTHREADS=1")
+  SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s USE_PTHREADS=1")
 ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
   SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
```

## SharedArrayBuffer

The second error we hit is

```
...
requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag
```

Emscripten translates `pthreads` into use of `SharedArrayBuffer`.  [`SharedArrayBuffer`][] is a
shared memory, and for security reasons, is not enabled by default.

Here, `toFloat.cpp` is compiled to `toFloat.js`, and `toFloat.js` is ran using node in order to
generate `toFloat.h`.  `toFloat` uses pthreads to parallelize the generation of some constant
values.  So, in order to run it correctly, we need to pass the `--experimental-wasm-threads` flag to
node.

We know that `node` is found and decided by [`Emscripten.cmake`][], so we can set this variable
ourselves. I couldn't even find this variable in CMake 3.1.0
[docs](https://cmake.org/cmake/help/v3.1/manual/cmake-variables.7.html), so I'm quite surprised it
even worked, and this is one reason why this project should upgrade the CMake version.


```
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1a7fef9..b41c368 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -4,6 +4,8 @@
 
 CMAKE_MINIMUM_REQUIRED ( VERSION 3.1.0 )
 
+SET(CMAKE_CROSSCOMPILING_EMULATOR "${CMAKE_SOURCE_DIR}/node-wrapper" CACHE STRING "Path to the emulator for the target system." FORCE)
+
 # For sanitizers
 SET (CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake" ${CMAKE_MODULE_PATH})
``` 

`node-wrapper` literally wraps node, passing it the appropriate flag:

```
$ cat ../node-wrapper
#!/bin/bash

/path/to/emsdk/node/12.9.1_64bit/bin/node --experimental-wasm-threads "$@"
```

## Hacking submodules

The next error is quite cryptic:

```
/bin/sh: ./dwaLookups: No such file or directory
```

For this we need to dig into
[`src/ext/openexr/OpenEXR/IlmImf/CMakeLists.txt`](https://github.com/wjakob/openexr/blob/84793a726d77ad6cb9a510011c3907df809c32a4/OpenEXR/IlmImf/CMakeLists.txt#L33):

```
ADD_CUSTOM_COMMAND (
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/dwaLookups.h
  COMMAND ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/dwaLookups > ${CMAKE_CURRENT_BINARY_DIR}/dwaLookups.h
  DEPENDS dwaLookups
)
```

Like `toFloat.js`, here an executable `dwaLookups.js` is generated, and ran
using [`CMAKE_CROSSCOMPILING_EMULATOR`][].  However, I suspect that the way this custom command was
defined broke something. Comparing it to
[`toFloat`](https://github.com/wjakob/openexr/blob/84793a726d77ad6cb9a510011c3907df809c32a4/IlmBase/Half/CMakeLists.txt#L15):

```
ADD_CUSTOM_COMMAND(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/toFloat.h
  COMMAND toFloat ARGS > ${CMAKE_CURRENT_BINARY_DIR}/toFloat.h
  DEPENDS toFloat
  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
  )
```

See how it only uses `toFloat` instead of trying to construct a path? I tried to look at the upstream
for a fix, but they don't even do this way of generating the header files anymore (these header
files are precomputed values), they [check it
in](https://github.com/AcademySoftwareFoundation/openexr/blob/master/OpenEXR/IlmImf/CMakeLists.txt)
directly.

So the fix is to change the `CMakeLists.txt`, and while we are here, also fix up the potential issue
with `b44ExpLogTable`:

    diff --git a/OpenEXR/IlmImf/CMakeLists.txt b/OpenEXR/IlmImf/CMakeLists.txt
    index 74ab6d5..9a50f53 100644
    --- a/OpenEXR/IlmImf/CMakeLists.txt
    +++ b/OpenEXR/IlmImf/CMakeLists.txt
    @@ -15,7 +15,7 @@ TARGET_LINK_LIBRARIES ( b44ExpLogTable

     ADD_CUSTOM_COMMAND (
       OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/b44ExpLogTable.h
    -  COMMAND ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/b44ExpLogTable > ${CMAKE_CURRENT_BINARY_DIR}/b44ExpLogTable.h
    +  COMMAND b44ExpLogTable > ${CMAKE_CURRENT_BINARY_DIR}/b44ExpLogTable.h
       DEPENDS b44ExpLogTable
     )

    @@ -32,7 +32,7 @@ TARGET_LINK_LIBRARIES ( dwaLookups

     ADD_CUSTOM_COMMAND (
       OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/dwaLookups.h
    -  COMMAND ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/dwaLookups > ${CMAKE_CURRENT_BINARY_DIR}/dwaLookups.h
    +  COMMAND dwaLookups > ${CMAKE_CURRENT_BINARY_DIR}/dwaLookups.h
       DEPENDS dwaLookups
     )

I much prefer `dwaLookups.h` to be checked in, I think it's a static file anyway, and it takes a
long time for the generated `dwaLookups.js` to run. (Maybe a performance issue worth looking into,
but probably not given upstream has checked in the header.)

At this point or later if you rebuild, you see that `dwaLookups.h` take a really long time to
complete. I suspect there is a deadlock somewhere, since generating `dwaLookups.h` uses pthreads,
but the library wasn't necessary written with Emscripten in mind. The quick fix is to make it
single-threaded:

```
diff --git a/OpenEXR/IlmImf/dwaLookups.cpp b/OpenEXR/IlmImf/dwaLookups.cpp
index 19ec831..cac958a 100644
--- a/OpenEXR/IlmImf/dwaLookups.cpp
+++ b/OpenEXR/IlmImf/dwaLookups.cpp
@@ -492,7 +492,7 @@ generateLutHeader()
         }
     }

-    if (IlmThread::supportsThreads()) {
+    if (false && IlmThread::supportsThreads()) {
         std::vector<LutHeaderWorker::Runner*> runners;
         for (size_t i=0; i<workers.size(); ++i) {
             runners.push_back( new LutHeaderWorker::Runner(*workers[i], (i==0)) );
```

It should now complete (but still takes a while).

## glog

The next error we have is:

```
/Users/ngzhian/src/pbrt-v3-wasm/src/ext/glog/src/raw_logging.cc:153:3: error: use of undeclared identifier 'syscall'
  safe_write(STDERR_FILENO, buffer, strlen(buffer));
  ^
/Users/ngzhian/src/pbrt-v3-wasm/src/ext/glog/src/raw_logging.cc:63:34: note: expanded from macro 'safe_write'
# define safe_write(fd, s, len)  syscall(SYS_write, fd, s, len)
```

Emscripten defines some syscalls, but not [all](https://github.com/emscripten-core/emscripten/issues/6708).

I don't understand what this code is doing, so the fix is to set `HAVE_SYSCALL_H` and `HAVE_SYS_SYSCALL_H` to false.

```
SET(HAVE_SYSCALL_H 0 CACHE INTERNAL "Hack for glog" FORCE)
SET(HAVE_SYS_SYSCALL_H 0 CACHE INTERNAL "Hack for glog" FORCE)
```

## undefined symbols

The next error is has to do with undefined symbol, `popen`:

    error: undefined symbol: popen (referenced by top-level compiled C/C++ code)
    warning: Link with `-s LLD_REPORT_UNDEFINED` to get more information on undefined symbols
    warning: To disable errors for undefined symbols use `-s ERROR_ON_UNDEFINED_SYMBOLS=0`
    warning: _popen may need to be added to EXPORTED_FUNCTIONS if it arrives from a system library
    Error: Aborting compilation due to previous errors
    em++: error: '/Users/ngzhian/src/emsdk/node/12.9.1_64bit/bin/node /Users/ngzhian/src/emsdk/upstream/emscripten/src/compiler.js /var/folders/1n/02brqmc95d51bdrmzz8hhmrc0000gn/T/tmpvw86fm__.txt' failed (1)

It tells us that we can disable this error, so let's try it with:

    SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s ERROR_ON_UNDEFINED_SYMBOLS=0")

## Inline data files

With all these changes, the compilation succeeds. We can try running `pbrt.js` with node, but
nothing really happens, because we need to pass it an input file.

```
$ node --experimental-wasm-threads pbrt.js < ../scenes/killeroo-simple.pbrt
<stdin>:45:37: Error: geometry/killeroo.pbrt: No such file or directory
<stdin>:49:37: Error: geometry/killeroo.pbrt: No such file or directory
...
```

The input file `killeroo-simple.pbrt` uses an `include` statement to include a geometery file (this a
DSL specific to pbrt). There are two paths we can do there:

1. [preload/embed](https://emscripten.org/docs/porting/files/packaging_files.html#packaging-files) the files using Emscripten, or
2. inline `geometry/killeroo.pbrt` - literally copy paste the contents

The second option seeemed easier so I just did that.

## OOM

After this, we get OOM messages. It helpfully suggests us to rebuild with `-s ASSERTIONS=1`.

In general, building with this flag is useful, it emits warnings and suggests fixes. In this case, I
know what the problem is: the program uses malloc to allocate memory for the large amounts of data
structures required for rendering, and at some point we run out of memory. When running on the web,
you don't have access to all of the memory the machine has, there is a cap of 2 or 4 Gb. Emscripten
sets the limit to even lower, 256 Wasm pages (64KB) or 16 Mb, so programs hit OOM even earlier. We
can compile with the ability to dynamically ask for more memory, or we can compile with a higher
initial memory. We do the latter here:

    SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s INITIAL_MEMORY=134217728")

Then after this, it should run fine, with

```
$ node --experimental-wasm-threads pbrt.js < ../scenes/killeroo-simple.pbrt
```

## Infinite loop?

Well, not really, there's not much progress, we don't see any output, so let's turn up the
verbosity (these are flags provided by the glog library that pbrt uses):

```
$ node --experimental-wasm-threads pbrt.js --logtostderr --minloglevel 0 < ../scenes/killeroo-simple.pbrt
...
I0607 15:18:39.470999 2969088 film.cpp:60] Created film with full resolution [ 700, 700 ]. Crop
window of [ [ 0, 0 ] - [ 1, 1 ] ] -> croppedPixelBounds [ [ 0, 0 ] - [ 700, 700 ] ]
I0607 15:18:39.954999 2969088 bvh.cpp:210] BVH created with 118377 nodes for 66533 primitives (3.61
MB), arena allocated 6.00 MB
```

We see that this is stuck after `BVH` creation. BVH is a data structure to accelerate ray tracing,
the details are not important here.

After some debugging, I found that where this was getting stuck is in the creation of
`ProgressReporter`, called by the [SamplerIntegrator][]. The constructor of `ProgressReporter` uses
some synchronization primitives to disable profiling, using a barrier, and I think that's not
working well. The role of the `ProgressReporter` is to, well, report progress using a pretty
progress bar in the terminal. Fortunately, this logic is guarded by a flag, so we can pass `--quiet`
to ignore this.

```
$ node --experimental-wasm-threads pbrt.js --logtostderr --minloglevel 0 --quiet <
../scenes/killeroo-simple.pbrt
... bunch of output with "image tile"
```

## Writing to stdout

And then after that it should run fine. But we don't really see anything. This is because pbrt
writes the output file to the filesytem. But since Emscripten emulates the file system using an
[in-memory file system](https://emscripten.org/docs/api_reference/Filesystem-API.html#memfs), the file is ephemeral and disappears after pbrt.js runs to the end. One fix
is to write to stdout, but we need to be aware that other parts of the program can be writing to
stdout too. So let's run with with all the logging removed and the quiet flag set:

```
$ node --experimental-wasm-threads pbrt.js --quiet < ../scenes/killeroo-simple.pbrt > test.pbm
```

> Note: Emscripten supports other kinds of filesystem, e.g.
> [NODEFS](https://emscripten.org/docs/api_reference/Filesystem-API.html#nodefs) for use when
> running on node, and will be able to persist files written onto disk. I found this out just as I
> was editing this blog post after I finished writing it...  If I had discovered this earlier, I
> would have used it. I chose to not update this blog spot, since I've already wrote the following
> chapters, and they contain useful tidbits, like UTF-8 when writing to stdout.

## UTF-8 output

However, if we open `test.pbm`, we see something nonsensical, just a bunch of noise. It is obviously
not what we want.

The problem here is, whenever we print/write something to stdout, Emscripten
converts it into UTF-8, since that's what JavaScript understands. So the buffer passed to `fwrite`
is treated as a UTF-8 encoded bytes, checked for valid encoding, and written out. However, our bytes
are arbitrary floats, so we end up with nonsense.

I don't have a great way to fix this, so what we will do is post-process the output. Instead of
writing bytes, we write ASCII values of the bytes, then have a postprocessing step outside of
Emscripten that converts them back into actual bytes.[^1]

[^1]: Actually if we had turned `ASSERTIONS` on, we would have seen:

    ```
    Invalid UTF-8 leading byte 0x-79 encountered when deserializing a UTF-8 string on the asm.js/wasm
    heap to a JS string!
    ```

    and this is an indication that what we are trying might not work.

The change to write the hex values to stdout is:

```
$ git diff -- src/core/imageio.cpp
diff --git a/src/core/imageio.cpp b/src/core/imageio.cpp
index 28f5c99..33bc0bb 100644
--- a/src/core/imageio.cpp
+++ b/src/core/imageio.cpp
@@ -439,7 +439,7 @@ static bool WriteImagePFM(const std::string &filename, const Float *rgb,
     FILE *fp;
     float scale;

-    fp = fopen(filename.c_str(), "wb");
+    fp = fopen("/dev/stdout", "wb");
     if (!fp) {
         Error("Unable to open output PFM file \"%s\"", filename.c_str());
         return false;
@@ -465,11 +465,12 @@ static bool WriteImagePFM(const std::string &filename, const Float *rgb,
     for (int y = height - 1; y >= 0; y--) {
         // in case Float is 'double', copy into a staging buffer that's
         // definitely a 32-bit float...
-        for (int x = 0; x < 3 * width; ++x)
+        for (int x = 0; x < 3 * width; ++x) {
             scanline[x] = rgb[y * width * 3 + x];
-        if (fwrite(&scanline[0], sizeof(float), width * 3, fp) <
-            (size_t)(width * 3))
-            goto fail;
+            int i;
+            memcpy(&i, &scanline[x], sizeof(float));
+            fprintf(fp, "%.8x", i);
+        }
     }

     fclose(fp);
```

The `%.8x` is important, it ensures that we always write 8 chars. If we have a float whose whose top 4 bits are 0, we will end up only writing 7 characters. This was a bug that I encountered.

## Post-processing

The post-processing is a little Python script to read in the floats written out in their hex form,
and then write out the actual bytes.

```
# postprocess.py
with open('test.pfm') as f:
    with open('out.pfm', 'wb') as o:
        # read headers
        for i in range(3):
            o.write(bytearray(f.readline(), encoding='utf-8'))
        # last byte is new line, don't need it
        data = f.readline()[:-1]
        # read 8 characters at a time, they form a single float
        for i in range(0, len(data), 8):
            fp = data[i:i+8];
            # write out in little endian
            ints = [int(fp[i*2:i*2+2], 16) for i in range(3,-1,-1)]
            o.write(bytearray(ints))
```

## Success

With that, we get `out.pfm` that is a valid file! And it looks very similar to the one generate from
the native version of pbrt. If you dump the hex and diff them, you see that they differ slightly, I
attribute that to floating points, maybe there is some precision error that happened during the
conversion.

## Next steps

At the end, we have a JS file that we can run using node, but this isn't really done yet, because we
can't run it in a browser yet. If we include this JS file in a HTML page, all that is is going to do
is print to console a series of ASCII-encoded bytes.

What we would like to do instead is show the PBM image somehow. One idea is to draw the PBM onto a
canvas. We will try that a future blog post.

## Concluding thoughts

This was a relatively fun exercise in porting a good sized project to WebAssembly. I hope this step
by step exercise gives you an idea of what sort of issues you might encounter while porting, and
also tips on how to look at the error messages and figure out how to fix things.

Emscripten is a big project and contains many useful flags to help you port. Turning them
(`ASSERTIONS`) on during the porting process can probably save you some time. The website contains a
lot of useful information, and also test cases in the Emscripten codebase shows how APIs can be
used. Those will serve as good examples for porting.


[`target_compile_options`]: https://cmake.org/cmake/help/v3.17/command/target_compile_options.html
[pthreads]: https://emscripten.org/docs/porting/pthreads.html
[`Emscripten.cmake`]: https://github.com/emscripten-core/emscripten/blob/master/cmake/Modules/Platform/Emscripten.cmake#L397
[`CMAKE_CROSSCOMPILING_EMULATOR`]: https://cmake.org/cmake/help/v3.17/prop_tgt/CROSSCOMPILING_EMULATOR.html#prop_tgt:CROSSCOMPILING_EMULATOR
[SamplerIntegrator]: https://github.com/mmp/pbrt-v3/blob/master/src/core/integrator.cpp#L238
[`SharedArrayBuffer`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer
