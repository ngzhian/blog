<!DOCTYPE html>
<html lang="en">
<head>
          <title>Zhi An</title>
        <meta charset="utf-8" />
        <link href="http://ngzhian.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Zhi An Full Atom Feed" />
        <link href="http://ngzhian.com/feeds/code.atom.xml" type="application/atom+xml" rel="alternate" title="Zhi An Categories Atom Feed" />




        <link rel="stylesheet" href="http://ngzhian.com/theme/css/styles.css">
        <link rel="stylesheet" href="http://ngzhian.com/theme/css/github.css">
</head>

<body id="index" class="home">
    <div class="content">
        <header id="banner" class="body">
                <a href="http://ngzhian.com/">
                    <img class="avatar" src="http://i.imgur.com/r3v4S9O.jpg">
                </a>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <time class="published" title="2015-04-20T19:00:00-04:00">
      Mon 20 April 2015
    </time>
    <h2 class="entry-title">
      <a href="http://ngzhian.com/what-the-heck-is-google-closure-compiler.html" rel="bookmark"
         title="Permalink to What the heck is Google Closure Compiler?">What the heck is Google Closure Compiler?</a></h2>
 
  </header>
  <footer class="post-info">
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>It "compiles from JavaScript to better JavaScript", so why would any one want that?</p>
<p>According to the <a href="https://github.com/google/closure-compiler">GitHub repo</a>, closure compiler does many amazing things:</p>
<ul>
<li>parses your JavaScript,</li>
<li>analyzes it,</li>
<li>removes dead code and rewrites</li>
<li>minimizes what's left</li>
<li>checks syntax, variable references, and types,</li>
<li>and warns about common JavaScript pitfalls</li>
</ul>
<p>That's pretty complicated. But no fear, this series will explore the Closure Compiler, one feature at a time.</p>
<p>Let's follow their instructions and try to run it from the command line.</p>
<div class="highlight"><pre>var x = 17 + 25;
</pre></div>


<div class="highlight"><pre>var x=42;
</pre></div>


<p>What noticeable differences are there?</p>
<ol>
<li><code>17 + 25</code> became <code>42</code></li>
<li>Space between and after <code>=</code> is gone</li>
</ol>
<p>So even for this simple one liner, closure compiler has managed to run 2 optimizations.</p>
<p>Let's examine these optimizations closer, and what better way to do that then jump into the debugger :)</p>
<h1>Running from the command line</h1>
<p>We create file called <code>in1.js</code> with the contents <code>var x = 17 + 25</code>, and in our debug configuration
specify the program arguments as <code>--js_output_file=out.js in1.js</code>.</p>
<p>We do this because we don't want to be typing input in the Eclipse console (I don't know how to do that :P)</p>
<p>The initial part isn't that interesting, we just initiate the <code>CommandLineRunner</code></p>
<div class="highlight"><pre>    <span class="n">CommandLineRunner</span> <span class="n">runner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CommandLineRunner</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">runner</span><span class="o">.</span><span class="na">shouldRunCompiler</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">runner</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
</pre></div>


<p>Which delegates work to <code>AbstractCommandLineRunner</code>'s <code>run()</code> method</p>
<div class="highlight"><pre>  <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">runs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">runs</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">doRun</span><span class="o">();</span>
      <span class="o">}</span>
</pre></div>


<p>Which then hands off to <code>doRun()</code></p>
<h4>Warning</h4>
<blockquote>
<p>I had to go into my debug configuration in eclipse and add the folder where <code>externs.zip</code> was located in so <code>getResourceAsStream</code> could find the file.
Basically <code>createExterns</code> copies all the files in <code>externs.zip</code> into a list that will be used later.</p>
</blockquote>
<p>The next steps just setting up the compiler with the appropriate options</p>
<div class="highlight"><pre>  <span class="kd">protected</span> <span class="kt">int</span> <span class="nf">doRun</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">FlagUsageException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">Compiler</span><span class="o">.</span><span class="na">setLoggingLevel</span><span class="o">(</span><span class="n">Level</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">loggingLevel</span><span class="o">));</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">SourceFile</span><span class="o">&gt;</span> <span class="n">externs</span> <span class="o">=</span> <span class="n">createExterns</span><span class="o">();</span>

    <span class="n">compiler</span> <span class="o">=</span> <span class="n">createCompiler</span><span class="o">();</span>
    <span class="n">B</span> <span class="n">options</span> <span class="o">=</span> <span class="n">createOptions</span><span class="o">();</span>
</pre></div>


<p>The part where usually the runner will wait for user input is here:</p>
<div class="highlight"><pre>      <span class="n">List</span><span class="o">&lt;</span><span class="n">SourceFile</span><span class="o">&gt;</span> <span class="n">inputs</span> <span class="o">=</span> <span class="n">createSourceInputs</span><span class="o">(</span><span class="n">jsFiles</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">skipNormalOutputs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">compiler</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">inputs</span><span class="o">,</span> <span class="n">options</span><span class="o">);</span>
        <span class="n">compiler</span><span class="o">.</span><span class="na">hoistExterns</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">inputs</span><span class="o">,</span> <span class="n">options</span><span class="o">);</span>
      <span class="o">}</span>
</pre></div>


<p>But because we supplied arguments to the parameter, it reads from that file and not <code>stdin</code>.</p>
<p>There are some set up steps again, and finally we jump into the <code>compile</code> method, the meat of
which happens in a separate thread it seems</p>
<div class="highlight"><pre>  <span class="kd">private</span> <span class="n">Result</span> <span class="nf">compile</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">runInCompilerThread</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&gt;()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="n">Result</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">compileInternal</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">getResult</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">});</span>
  <span class="o">}</span>
</pre></div>


<p>Because it is a separate thread, I had to set a breakpoint inside <code>compileInternal</code>
in order to take a look at what's happening.</p>
<h2>Inside the compiler</h2>
<p>Some very small set up to process compiler options and initialize progress state, but
there's a very interesting comment here:</p>
<div class="highlight"><pre>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">compileInternal</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">setProgress</span><span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">CompilerOptionsPreprocessor</span><span class="o">.</span><span class="na">preprocess</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>
    <span class="n">parse</span><span class="o">();</span>
    <span class="c1">// 15 percent of the work is assumed to be for parsing (based on some</span>
    <span class="c1">// minimal analysis on big JS projects, of course this depends on options)</span>
    <span class="n">setProgress</span><span class="o">(</span><span class="mf">0.15</span><span class="o">,</span> <span class="s">&quot;parse&quot;</span><span class="o">);</span>
</pre></div>


<p>We're not going to dive into the <code>parse</code> method, that's not what we're after.</p>
<p>From a cursory look into the method, <code>parse</code> parses the inputs and returns an AST. This AST is stored in the jsRoot instance variable</p>
<p>And we end up in the <code>optimize</code> method! Okay I have a feeling this is where things are going to get exciting.</p>
<div class="highlight"><pre>        <span class="n">optimize</span><span class="o">();</span>
</pre></div>


<p>First it gathers up a list of optimizations that will be performed, e.g.</p>
<ul>
<li>gatherExternProperties,</li>
<li>garbageCollectChecks</li>
</ul>
<p>A list of all these optimizations can be found in the <code>getOptimizations</code> method of <code>DefaultPassConfig</code>.</p>
<p>From how the code looks like, each optimization is also called a <code>pass</code>.</p>
<div class="highlight"><pre>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">optimize</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">PassFactory</span><span class="o">&gt;</span> <span class="n">optimizations</span> <span class="o">=</span> <span class="n">getPassConfig</span><span class="o">().</span><span class="na">getOptimizations</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">optimizations</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p>Observe how <code>optimizations</code> is a <code>List</code> of <code>PassFactory</code> (factory pattern).</p>
<p>The first pass is the <code>normalize</code> pass. It seems like for each pass there is a set of steps that must be followed, something like:</p>
<ol>
<li><code>startPass</code> is called with the name of the pass</li>
<li>actually process the pass</li>
<li><code>endPass</code> is called, probably for cleanup effects</li>
</ol>
<p><code>startPass</code> itself has a number of steps as well:</p>
<ol>
<li>check the current state of passing</li>
<li>set <code>currentPassName</code> to signify what pass it is</li>
<li>set <code>currentTracer</code> to a new <code>Tracer</code></li>
</ol>
<p>I haven't dug into what a <code>Tracer</code> does, but from the comments it looks like it figures out how long a particular action took, and thus will be useful when you want to pin point slow areas in the code.</p>
<p>So let's jump into the work that <code>normalize</code> actually does.</p>
<p>It's not difficult to see what it does, because most of it is well document in the <code>Normalize</code> class.</p>
<p>Here's directly quoting the docs:</p>
<div class="highlight"><pre><span class="o">/**</span>
 <span class="o">*</span> <span class="n">The</span> <span class="n">goal</span> <span class="n">with</span> <span class="k">this</span> <span class="n">pass</span> <span class="n">is</span> <span class="n">to</span> <span class="n">simplify</span> <span class="n">the</span> <span class="n">other</span> <span class="n">passes</span><span class="o">,</span>
 <span class="o">*</span> <span class="n">by</span> <span class="n">making</span> <span class="n">less</span> <span class="n">complex</span> <span class="n">statements</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">Starting</span> <span class="n">with</span> <span class="n">statements</span> <span class="n">like</span><span class="o">:</span>
 <span class="o">*</span>   <span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="o">();</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">Which</span> <span class="n">become</span><span class="o">:</span>
 <span class="o">*</span>   <span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
 <span class="o">*</span>   <span class="n">var</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="o">();</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">The</span> <span class="n">key</span> <span class="n">here</span> <span class="n">is</span> <span class="n">only</span> <span class="n">to</span> <span class="k">break</span> <span class="n">down</span> <span class="n">things</span> <span class="n">that</span> <span class="n">help</span> <span class="n">the</span> <span class="n">other</span> <span class="n">passes</span>
 <span class="o">*</span> <span class="n">and</span> <span class="n">can</span> <span class="n">be</span> <span class="n">put</span> <span class="n">back</span> <span class="n">together</span> <span class="n">in</span> <span class="n">a</span> <span class="n">form</span> <span class="n">that</span> <span class="n">is</span> <span class="n">at</span> <span class="n">least</span> <span class="n">as</span> <span class="n">small</span> <span class="n">when</span>
 <span class="o">*</span> <span class="n">all</span> <span class="n">is</span> <span class="n">said</span> <span class="n">and</span> <span class="n">done</span><span class="o">.</span>
</pre></div>


<p>If you keep looking down, you see descriptions about the 7 things that this class does.</p>
<p>After some set up, the <code>process</code> method of <code>Normalize</code> is called, and that's where magic happens!</p>
<h2>Traversing/Visiting</h2>
<p>The first step is strange to me at first sight:</p>
<div class="highlight"><pre>    <span class="k">new</span> <span class="n">NodeTraversal</span><span class="o">(</span>
        <span class="n">compiler</span><span class="o">,</span> <span class="k">new</span> <span class="n">NormalizeStatements</span><span class="o">(</span><span class="n">compiler</span><span class="o">,</span> <span class="n">assertOnChange</span><span class="o">))</span>
        <span class="o">.</span><span class="na">traverseRoots</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
</pre></div>


<p>It looks like this isn't doing anything. But we we look into what <code>NodeTraversal</code> does, it actually takes in a <code>Callback</code>, and when it traverses the AST (<code>traverseRoots</code>), it calls particular methods of <code>Callback</code> at different points of traversing.</p>
<p>For example, <code>traverseRoots</code> calls <code>traverseBranch</code></p>
<div class="highlight"><pre>      <span class="n">traverseBranch</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">scopeRoot</span><span class="o">);</span>
</pre></div>


<p>and in <code>traverseBranch</code>, it calls the <code>visit</code> method of the callback</p>
<div class="highlight"><pre>    <span class="n">callback</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">parent</span><span class="o">);</span>
</pre></div>


<p>In summary the <code>NodeTraversal</code> goes through the AST and at various points, asks the <code>Callback</code> if it wants to visit a particular node (visitor pattern).</p>
<p>Now we can see what <code>NormalizeStatements</code> does.</p>
<p>There are really only 2 methods of interest here, <code>shouldTraverse</code> and <code>visit</code>.</p>
<p><code>shouldTraverse</code> is <code>NormalizeStatements</code> way of saying if it should descend down one level in the AST.</p>
<p><code>visit</code> is what <code>NormalizeStatements</code> will do to modify the AST.</p>
<p>Looking into <code>shouldTraverse</code> we see that first, it always returns <code>true</code>, and it does some normalizations inside of this method</p>
<div class="highlight"><pre>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">shouldTraverse</span><span class="o">(</span><span class="n">NodeTraversal</span> <span class="n">t</span><span class="o">,</span> <span class="n">Node</span> <span class="n">n</span><span class="o">,</span> <span class="n">Node</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">doStatementNormalizations</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p>If we dive deeper into the code we can see very well written comments why certain normalizations are done in the <code>shouldTraverse</code> method, and why others are done in the <code>visit</code>.</p>
<p>For example, in <code>doStatementNormalizations</code>, the <code>extractForInitializer</code> method is called, and the comments are as such:</p>
<div class="highlight"><pre>    <span class="cm">/**</span>
<span class="cm">     * Bring the initializers out of FOR loops.  These need to be placed</span>
<span class="cm">     * before any associated LABEL nodes. This needs to be done from the top</span>
<span class="cm">     * level label first so this is called as a pre-order callback (from</span>
<span class="cm">     * shouldTraverse).</span>
<span class="cm">     *</span>
<span class="cm">     * @param n The node to inspect.</span>
<span class="cm">     * @param before The node to insert the initializer before.</span>
<span class="cm">     * @param beforeParent The parent of the node before which the initializer</span>
<span class="cm">     *     will be inserted.</span>
<span class="cm">     */</span>
</pre></div>


<p>Because it's a AST traversal implemented with callbacks, it wasn't easy to get to the code that was interesting. A lot of is was just descending the AST (in what looks like a depth first manner), before we finally get to the <code>visit</code> part of the code.</p>
<p>Particularly I hit a point where I ended up in this switch case:</p>
<div class="highlight"><pre>        <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">SETTER_DEF</span><span class="o">:</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">compiler</span><span class="o">.</span><span class="na">getLifeCycleStage</span><span class="o">().</span><span class="na">isNormalizedObfuscated</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">annotateConstantsByConvention</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">parent</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">break</span><span class="o">;</span>
</pre></div>


<p>I couldn't understand what <code>Token.SETTER_DEF</code> meant, so I went to the Variables panel in eclipse and looked at what <code>n</code> was (the switch block switched on <code>n.getType()</code>), and saw that n was "x".</p>
<p>The rest of the <code>process</code> method looks similar, where callbacks are passed into a travesal, with different callbacks doing different things.</p>
<p>The slight differences are the types of <code>Callback</code>s used.</p>
<p><code>NormalizeStatements</code> implements the <code>Callback</code> interface at the highest level, and there over 20 classes or abstract classes that implement this interface.</p>
<p><code>MakeDeclaredNamesUnique</code> implements the ScopedCallback, because when renaming variables, scope has to be considered. E.g. a variable that refers to a variable in the outer scope cannot be renamed to something different.</p>
<p>Here's something that caused me difficulty in reading this particular method: there are multiple layers of abstraction here, which makes it pretty confusing.</p>
<ol>
<li>It's not clear how many things <code>process</code> is actually doing.</li>
<li>The actions are inconsistent. In some places, the construction of a <code>NodeTraversal</code> using <code>new</code> and calling <code>traverseRoots</code> happens on the same line. But in others, the <code>Callback</code> is constructed separately from the <code>NodeTraversal</code>, which are separate from actually calling the <code>traverse</code> method. In other places, these 3 steps are separated into another method.</li>
</ol>
<p>Perhaps to clean up this method slightly, we can move each sub-processing step into its own method, like <code>removeDuplicateDeclarations</code></p>
<div class="highlight"><pre>    <span class="n">removeDuplicateDeclarations</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
</pre></div>


<p>Then <code>process</code> will look like this</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">Node</span> <span class="n">externs</span><span class="o">,</span> <span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">normalizeStatements</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="n">makeDeclaredNamesUnique</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="n">removeDuplicateDeclarations</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="n">propagateConstantAnnotationsOverVars</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="n">findExposeAnnotations</span><span class="o">(</span><span class="n">root</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>


<p>For our simple piece of code, <code>normalize</code> actually doesn't do anything, so that was a pretty long detour. But I think we will see the patterns in <code>normalize</code> again thorughout the codebase, so it is useful to examine it.</p>
<p>For each <code>startPass</code>, there is its dual <code>endPass</code>, which stops the <code>Tracer</code> (so a tracer probably records how long each compiler pass took).</p>
<h1>The PhaseOptimizer</h1>
<p>And we're back in <code>optimize</code>! Here we hit something scary (to me) called the <code>PhaseOptimizer</code>.
We throw all the optimizations in to the <code>phaseOptimizer</code> via its <code>consume</code> method, and basically <code>consume</code> organizes these <code>PassFactory</code>-ies into <code>CompilePasses</code>.</p>
<p>Like its name suggest, <code>PhaseOptimizer</code> does some optimizations. These are (for now) too complicated to get into, but here are relevant portions of the code that describes what happens:</p>
<div class="highlight"><pre>  <span class="cm">/**</span>
<span class="cm">   * Add the passes generated by the given factories to the compile sequence.</span>
<span class="cm">   * &lt;p&gt;</span>
<span class="cm">   * Automatically pulls multi-run passes into fixed point loops. If there</span>
<span class="cm">   * are 1 or more multi-run passes in a row, they will run together in</span>
<span class="cm">   * the same fixed point loop. The passes will run until they are finished</span>
<span class="cm">   * making changes.</span>
<span class="cm">   * &lt;p&gt;</span>
<span class="cm">   * The PhaseOptimizer is free to tweak the order and frequency of multi-run</span>
<span class="cm">   * passes in a fixed-point loop.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="nf">consume</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">PassFactory</span><span class="o">&gt;</span> <span class="n">factories</span><span class="o">)</span> <span class="o">{</span>
</pre></div>


<div class="highlight"><pre>  <span class="cm">/**</span>
<span class="cm">   * A compound pass that contains atomic passes and runs them until they reach</span>
<span class="cm">   * a fixed point.</span>
<span class="cm">   * &lt;p&gt;</span>
<span class="cm">   * Notice that this is a non-static class, because it includes the closure</span>
<span class="cm">   * of PhaseOptimizer.</span>
<span class="cm">   */</span>
  <span class="nd">@VisibleForTesting</span>
  <span class="kd">class</span> <span class="nc">Loop</span> <span class="kd">implements</span> <span class="n">CompilerPass</span> <span class="o">{</span>
</pre></div>


<p>At the end of <code>consume</code>, what we have is <code>passes</code> which is a list of <code>CompilerPass</code>-es that will be run. We then call the <code>process</code> method of the <code>PhaseOptimizer</code>, which goes through each <code>CompilerPass</code> (in <code>passes</code>) and calls the <code>process</code> method of that <code>CompilerPass</code>.</p>
<p>This should look pretty familiar because <code>Normalize</code> actually implements <code>CompilerPass</code>, and so we have a clue of what happens in the <code>process</code> method of each <code>CompilerPass</code>.</p>
<p>I wanted to figure out which exact <code>CompilerPass</code> was causing the change, so I added some if else and print statements to notify me when the nodes were changed by a pass. This is how it roughly looked like</p>
<div class="highlight"><pre>      <span class="n">String</span> <span class="n">old_root_str</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">toStringTree</span><span class="o">();</span>
      <span class="n">pass</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">externs</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
      <span class="n">String</span> <span class="n">new_root_str</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">toStringTree</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">old_root_str</span><span class="o">.</span><span class="na">contentEquals</span><span class="o">(</span><span class="n">new_root_str</span><span class="o">)){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Same: &quot;</span> <span class="o">+</span> <span class="n">pass</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Pass: &quot;</span> <span class="o">+</span> <span class="n">pass</span> <span class="o">+</span> <span class="s">&quot; old: &quot;</span> <span class="o">+</span> <span class="n">old_root_str</span> <span class="o">+</span> <span class="s">&quot; new: &quot;</span> <span class="o">+</span> <span class="n">new_root_str</span><span class="o">);</span>
      <span class="o">}</span>
</pre></div>


<p>What I found strange is that the <code>process</code> method of <code>PhaseOptimizer</code> ran twice. I found out because I had set breakpoints in that method.</p>
<p>In the first run of <code>process</code>, there was only 1 pass that caused a change: <code>inferConsts</code>, but I couldn't tell what changed based on the <code>toString()</code> output, so this isn't the pass we are interested in.</p>
<p>In the second run of <code>process</code>, we get this:</p>
<div class="highlight"><pre><span class="n">Same</span><span class="o">:</span> <span class="n">pass</span><span class="o">:</span> <span class="n">beforeMainOptimizations</span>
<span class="n">Pass</span><span class="o">:</span> <span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">javascript</span><span class="o">.</span><span class="na">jscomp</span><span class="o">.</span><span class="na">PhaseOptimizer</span><span class="n">$Loop</span><span class="err">@</span><span class="n">dd37992</span> <span class="n">old</span><span class="o">:</span> <span class="n">BLOCK</span> <span class="o">[</span><span class="n">synthetic</span><span class="o">:</span> <span class="mi">1</span><span class="o">]</span>
    <span class="n">SCRIPT</span> <span class="mi">1</span> <span class="o">[</span><span class="n">synthetic</span><span class="o">:</span> <span class="mi">1</span><span class="o">]</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span> <span class="o">[</span><span class="n">input_id</span><span class="o">:</span> <span class="n">InputId</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
        <span class="n">VAR</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
            <span class="n">NAME</span> <span class="n">x</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span> <span class="o">[</span><span class="n">is_constant_var</span><span class="o">:</span> <span class="mi">1</span><span class="o">]</span>
                <span class="n">ADD</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
                    <span class="n">NUMBER</span> <span class="mf">17.0</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
                    <span class="n">NUMBER</span> <span class="mf">25.0</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
 <span class="k">new</span><span class="o">:</span> <span class="n">BLOCK</span> <span class="o">[</span><span class="n">synthetic</span><span class="o">:</span> <span class="mi">1</span><span class="o">]</span> <span class="o">[</span><span class="n">change_time</span><span class="o">:</span> <span class="mi">15</span><span class="o">]</span>
    <span class="n">SCRIPT</span> <span class="mi">1</span> <span class="o">[</span><span class="n">synthetic</span><span class="o">:</span> <span class="mi">1</span><span class="o">]</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span> <span class="o">[</span><span class="n">input_id</span><span class="o">:</span> <span class="n">InputId</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
        <span class="n">VAR</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
            <span class="n">NAME</span> <span class="n">x</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span> <span class="o">[</span><span class="n">is_constant_var</span><span class="o">:</span> <span class="mi">1</span><span class="o">]</span>
                <span class="n">NUMBER</span> <span class="mf">42.0</span> <span class="mi">1</span> <span class="o">[</span><span class="n">source_file</span><span class="o">:</span> <span class="n">in1</span><span class="o">.</span><span class="na">js</span><span class="o">]</span>
<span class="n">Same</span><span class="o">:</span> <span class="n">pass</span><span class="o">:</span> <span class="n">beforeModuleMotion</span>
</pre></div>


<p>Bingo! Or not?</p>
<h2>Multiple passes</h2>
<p>We managed to figure out the pass that caused the optimization, but the name of the pass didn't really help at all.</p>
<p>But at least we know this pass happens before <code>beforeModuleMotion</code> and after <code>beforeMainOptimizations</code>, and because the list of <code>CompilerPass</code> is traversed in order, we can go into <code>DefaultPassConfig</code> and take a look at what is in between these 2 passes.</p>
<div class="highlight"><pre>    <span class="n">passes</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">getMainOptimizationLoop</span><span class="o">());</span>
</pre></div>


<p>This basically adds about 10+ <code>PassFactory</code>-ies to the list via the methods <code>getMainOptimizationLoop</code> and <code>getCodeRemovingPasses</code>.</p>
<p>By setting more debug breakpoints, I was able to narrow down my options to those found in <code>getCodeRemovingPasses</code>. Now I guess I just have to read what each pass does, or set breakpoints in every pass and observe what happens!</p>
<p>I think the former isn't a good idea, because the <code>PhaseOptimizer</code> might run each pass multiple times, and I'll just be debugging for a long time.</p>
<p>Here, I basically looked at each of them, read the comments and figure out what was likely to be the <code>CompilerPass</code> that did some work. My guess is that <code>PeepholeOptimizationsPass</code> did it.</p>
<p>Digging into the creation of <code>PeepholeOptimizationsPass</code> we see multiple kinds of peephole optimizations</p>
<div class="highlight"><pre>  <span class="cm">/** Various peephole optimizations. */</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">PassFactory</span> <span class="n">peepholeOptimizations</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">PassFactory</span><span class="o">(</span><span class="s">&quot;peepholeOptimizations&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">CompilerPass</span> <span class="nf">create</span><span class="o">(</span><span class="n">AbstractCompiler</span> <span class="n">compiler</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">late</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">PeepholeOptimizationsPass</span><span class="o">(</span><span class="n">compiler</span><span class="o">,</span>
            <span class="k">new</span> <span class="n">PeepholeMinimizeConditions</span><span class="o">(</span><span class="n">late</span><span class="o">),</span>
            <span class="k">new</span> <span class="n">PeepholeSubstituteAlternateSyntax</span><span class="o">(</span><span class="n">late</span><span class="o">),</span>
            <span class="k">new</span> <span class="n">PeepholeReplaceKnownMethods</span><span class="o">(</span><span class="n">late</span><span class="o">),</span>
            <span class="k">new</span> <span class="n">PeepholeRemoveDeadCode</span><span class="o">(),</span>
            <span class="k">new</span> <span class="n">PeepholeFoldConstants</span><span class="o">(</span><span class="n">late</span><span class="o">),</span>
            <span class="k">new</span> <span class="n">PeepholeCollectPropertyAssignments</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">};</span>
</pre></div>


<p>I decided to brute force and figure out which of these are responsible for the AST changes, so I basically just removed these <code>AbstractPeepholeOptimization</code> one by one until the AST didn't change, that way I can figure out which one is responsible.</p>
<p>Here I stumbled upon a funny little problem that took me a good deal of debuggin to solve.</p>
<p>Since we figure that the pass happens in <code>getMainOptimizationLoop</code>, I tried commenting that part out, but found that the pass still happened! That was really strange. Here's the part I commented out:</p>
<div class="highlight"><pre>    <span class="n">passes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">createEmptyPass</span><span class="o">(</span><span class="s">&quot;beforeModuleMotion&quot;</span><span class="o">));</span>
</pre></div>


<p>What I ended up doing was to slowly comment out parts of the <code>getOptimizations</code> method, which <code>getMainOptimizationLoop</code> lives in, and see when I can get the the pass to not be processed.</p>
<p>While going through the file to comment the code I took glances at the code as well and found out that in multiple places <code>PeepholeOptimizationsPass</code> was inserted in to the list of <code>CompilerPass</code>!</p>
<div class="highlight"><pre>        <span class="n">passes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">peepholeOptimizations</span><span class="o">);</span>
</pre></div>


<div class="highlight"><pre>      <span class="n">passes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">latePeepholeOptimizations</span><span class="o">);</span>
</pre></div>


<p>To reduce the surface area of search, we will comment out all of these except for 1,</p>
<div class="highlight"><pre>        <span class="n">passes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">peepholeOptimizations</span><span class="o">);</span>
</pre></div>


<p>Now we can proceed to comment out parts of <code>peepholeOptimizations</code> to figure out which exact <code>AbstractPeepholeOptimization</code> is doing the work, which is <code>PeepholeFoldConstants</code>.</p>
<p>This optimzation is not that simple to understand because it is made up of multiple smaller peephole optimizations.</p>
<p>Let's start from the top, which is a <code>PeepholeOptimizationsPass</code>. As per normal, this is a <code>CompilerPass</code>, so the <code>process</code> method is where this happen.</p>
<div class="highlight"><pre>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">Node</span> <span class="n">externs</span><span class="o">,</span> <span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">compiler</span><span class="o">.</span><span class="na">addChangeHandler</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
    <span class="n">beginTraversal</span><span class="o">();</span>
    <span class="n">NodeTraversal</span><span class="o">.</span><span class="na">traverseChangedFunctions</span><span class="o">(</span><span class="n">compiler</span><span class="o">,</span> <span class="k">new</span> <span class="n">FunctionCallback</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">AbstractCompiler</span> <span class="n">compiler</span><span class="o">,</span> <span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">isFunction</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">getLastChild</span><span class="o">();</span>
          <span class="o">}</span>
          <span class="k">do</span> <span class="o">{</span>
            <span class="n">handler</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
            <span class="n">NodeTraversal</span><span class="o">.</span><span class="na">traverse</span><span class="o">(</span><span class="n">compiler</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span> <span class="k">new</span> <span class="n">PeepCallback</span><span class="o">());</span>
          <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">retraverseOnChange</span> <span class="o">&amp;&amp;</span> <span class="n">handler</span><span class="o">.</span><span class="na">hasCodeChanged</span><span class="o">());</span>
        <span class="o">}</span>
      <span class="o">});</span>
    <span class="n">endTraversal</span><span class="o">();</span>
    <span class="n">compiler</span><span class="o">.</span><span class="na">removeChangeHandler</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>


<p>In <code>process</code> we see something different, the usage of <code>NodeTraversal.traverseChangedFunctions</code>.</p>
<p>This works similarly to the <code>Callbacks</code> we discussed above, except that the traversal only happens when functions are changed. The callback for this traversal is actually called <code>PeepCallback</code>, which runs each <code>AbstractPeepholeOptimization</code> when visiting each node by calling their <code>optimizeSubtree</code> method.</p>
<div class="highlight"><pre>  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">PeepCallback</span> <span class="kd">extends</span> <span class="n">AbstractShallowCallback</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">NodeTraversal</span> <span class="n">t</span><span class="o">,</span> <span class="n">Node</span> <span class="n">n</span><span class="o">,</span> <span class="n">Node</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Node</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">n</span><span class="o">,</span> <span class="n">newNode</span><span class="o">;</span>
      <span class="kt">boolean</span> <span class="n">codeChanged</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
      <span class="k">do</span> <span class="o">{</span>
        <span class="n">codeChanged</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">AbstractPeepholeOptimization</span> <span class="n">optim</span> <span class="o">:</span> <span class="n">peepholeOptimizations</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">newNode</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="na">optimizeSubtree</span><span class="o">(</span><span class="n">currentNode</span><span class="o">);</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">newNode</span> <span class="o">!=</span> <span class="n">currentNode</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">codeChanged</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">currentNode</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
          <span class="o">}</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">currentNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span> <span class="k">while</span><span class="o">(</span><span class="n">codeChanged</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div>


<h2>Finally, we found it!</h2>
<p>Now we know where to look to find out what <code>PeepholeFoldConstants</code> does.</p>
<div class="highlight"><pre>  <span class="n">Node</span> <span class="nf">optimizeSubtree</span><span class="o">(</span><span class="n">Node</span> <span class="n">subtree</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span><span class="o">(</span><span class="n">subtree</span><span class="o">.</span><span class="na">getType</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">NEW</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">tryFoldCtorCall</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>

      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">TYPEOF</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">tryFoldTypeof</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>

      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">NOT</span><span class="o">:</span>
      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">POS</span><span class="o">:</span>
      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">NEG</span><span class="o">:</span>
      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">BITNOT</span><span class="o">:</span>
        <span class="n">tryReduceOperandsForOp</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">tryFoldUnaryOperator</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>

      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">VOID</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">tryReduceVoid</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>

<span class="nl">      default:</span>
        <span class="n">tryReduceOperandsForOp</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">tryFoldBinaryOperator</span><span class="o">(</span><span class="n">subtree</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div>


<p>Reading the code we can guess which switch case we will land into, the <code>default</code> case.</p>
<p>Here we're just going to make a guess which method does the optimization, I'm going to pick <code>tryFoldBinaryOperator</code> because it sounds like it.</p>
<p>Jumping in we see a switch statement switching on the type of the subtree, which in our case is an addition. So we dive into the <code>tryFoldAdd</code> method.</p>
<div class="highlight"><pre>      <span class="k">case</span> <span class="n">Token</span><span class="o">.</span><span class="na">ADD</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">tryFoldAdd</span><span class="o">(</span><span class="n">subtree</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
</pre></div>


<p>We encounter some useful comments here so we can jump straight into the <code>else</code> branch.</p>
<div class="highlight"><pre>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// Try arithmetic add</span>
      <span class="n">Node</span> <span class="n">result</span> <span class="o">=</span> <span class="n">tryFoldArithmeticOp</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">tryFoldLeftChildOp</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div>


<p>To verify that this is indeed the optimization we care about, we can jump into the method and just result whatever was passed in.</p>
<p>Success!</p>
<p>By commenting out the lines in <code>tryFoldArithmeticOp</code> and just return <code>n</code>, we can verify that the optimization does not run!</p>
<p>We can dig deeper and look into <code>performArithmeticOp</code>, but all we need to know is that it performs the addition, returning a Node. If the addition worked, Node would just be a number, which is the result of the addition (in our case thats 42), and replace <code>n</code> (which was a <code>add</code> subtree), with just a single node!</p>
<h1>Recap</h1>
<p>After this long post, I think it's worth recapping what happens.</p>
<ol>
<li>The compiler is set up with options, things like where to get the JS (stdin or a file?)</li>
<li>JavaScript is parsed into a tree</li>
<li>Gather up the list of optimizations that will be run</li>
<li>normalize (which is actually a compiler pass)</li>
<li>Feed the list of optimziations into the <code>PhaseOptimizer</code></li>
<li><code>PhaseOptimizer</code> will run through all the optimizations</li>
<li>Each <code>CompilerPass</code> will process the AST via callbacks when traversing the tree</li>
<li>Compiled JavaScript is output (to stdout or file)</li>
</ol>
<p>There's way more that goes on, like how the <code>PhaseOptimizer</code> runs the list of optimizations, fixed-point optimizations that can be run multiple times safely, the many different kinds of <code>Callback</code>s.</p>
<p>But at a high level, this is how things are run.</p>
<p>Conclusion:</p>
<ol>
<li>Open source is awesome. Because Google released this source code, we can look into the code to figure out how things work!</li>
<li>Debuggers are super useful. Because Eclipse, and other IDEs, are such fantastic tools, we can insert breakpoints, jump around code, build and run projects with ease.</li>
<li>Patterns are useful! In this dive into the code, we have already observed a couple of design patterns, namely the Visitor pattern and the Factory pattern. This has allowed the compiler to stay very flexible. I can imagine adding a new optimization pass by declaring a couple of new classes without touching the core of the compiler</li>
</ol>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
    </div>
</body>
</html>