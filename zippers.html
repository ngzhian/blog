<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="author" content="Ng Zhi An">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,700" rel="stylesheet" type="text/css">
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Zippers</title>
  <style type="text/css">
    body {
        font-family: 'Pt Sans', 'Open Sans', sans-serif;
        font-size: 20px;
        line-height: 1.6;
        background: #fcfcfc;
        color: #333;
    }

    ul {
        list-style-type: circle;
    }

    a {
        color: #4A4A4A;
    }

    .entry-content a {
        color: #9FBF2E;
    }

    blockquote {
        border-left: 2px solid #eee;
        padding-left: 1rem;
        color: #666;
    }

    a:hover {
        color: #7A7A7A;
    }

    /* link to home at the top of each post */
    .home {
        font-size: 0.8em;
        color: #888;
    }

    .content {
        padding: 30px;
        max-width: 768px;
        margin: auto auto;
    }

    #post-list td {
        padding: 5px;
    }

    @media (max-width: 600px) {
      #post-list tr td:nth-child(1)  {
        display: none;
      }
    }

    #post-list tr td:nth-child(1)  {
      white-space: nowrap;
    }

    /* date published on index page */
    .published, .date {
        font-weight: normal;
        font-size: 0.9rem;
        color: #aaa;
    }

    pre {
        border: solid 1px #d9d9d9;
        border-radius: 5px;
        background: #f0f0f0;
        padding: 12px;
        font-size: 18px;
        line-height: 1.6;
        margin-bottom: 30px;
        overflow-x: auto;
    }

    footer {
        margin: 80px 0 20px 0;
        font-size: 14px;
    }

    code{
        white-space: pre;
    }

    p code {
        background: #f0f0f0;
    }
  </style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<section class="content">
<a class="home" href="./index.html">Home</a>
<div id="header">
<h1 class="title">Zippers</h1>
<h3 class="date">2017-04-29 14:00</h3>
</div>
<p>A zipper is a technique for implementing data structures (such as lists and trees) with some idea of a <em>focus</em> on one particular element, at the same time allowing for fast, functional (immutable) updates of a <em>specific point</em> in the structure.</p>
<p>Let's try building a list in the style of a zipper.</p>
<p>First we define a data type for a list zipper.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** A list zipper.</span>
<span class="co">    It maintains focus on 1 particular element in the list. *)</span>
<span class="kw">type</span> &#39;a list_zipper = &#39;a <span class="dt">list</span> * &#39;a <span class="dt">list</span></code></pre></div>
<p>Strange enough, a list zipper is made up of 2 lists, let's call it <em>back</em> and <em>front</em>. (This may seem strange, but we will see the benefits soon.)</p>
<p>Let's have a convenience function to build a list zipper from a normal list.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Builds a list zipper from a list. *)</span>
<span class="kw">let</span> zipper_of_list xs = ([], xs)</code></pre></div>
<p>The initial focus of the list zipper will be the first element of the front.</p>
<p>We can move the focus <em>forward</em> on to the next element of the front</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Move the focus in the list zipper forward *)</span>
<span class="kw">let</span> forward z =
  <span class="kw">match</span> z <span class="kw">with</span>
  | (bs, x::xs) -&gt; <span class="dt">Some</span> (x::bs, xs)
  | (_, []) -&gt; <span class="dt">None</span></code></pre></div>
<p>The interesting here is that the back list is actually reversed. Given a list <code>[1; 2; 3; 4]</code>, if we build a zipper and focused on 3, the front and back list will look like this:</p>
<pre><code>front = [2; 1]
back = [3; 4]</code></pre>
<p>Notice how we cannot concatenate the front and the back list to get the original list. In fact, to reconstruct the original list, the easy way is:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Converts a list zipper back into a list. *)</span>
<span class="kw">let</span> list_of_zipper (z : &#39;a list_zipper) =
  <span class="kw">match</span> z <span class="kw">with</span>
  | xs, ys -&gt; <span class="dt">List</span>.rev xs @ ys</code></pre></div>
<p>This reversed form is how we get moving focus to be efficient.</p>
<p>And similarly, we can move the focus <em>backwards</em>.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Move the focus in the list zipper backward *)</span>
<span class="kw">let</span> backward z =
  <span class="kw">match</span> z <span class="kw">with</span>
  | (b::bs, xs) -&gt; <span class="dt">Some</span> (bs, b::xs)
  | ([], _) -&gt; <span class="dt">None</span></code></pre></div>
<p>Here, the <code>::</code> operator (like <code>cons</code>), is fast and we can only do this if the back list is reversed.</p>
<p>The last operation the list zipper supports is changing the focused element.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Set the current focused value in the list to x *)</span>
<span class="kw">let</span> set x z =
  <span class="kw">match</span> z <span class="kw">with</span>
  | (bs, _::xs) -&gt; <span class="dt">Some</span> (bs, x::xs)
  | (_, []) -&gt; <span class="dt">None</span></code></pre></div>
<p>With this data structure and the operations defined, you can get fast, functional updates on a list:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* construct a simple list zipper *)</span>
<span class="kw">let</span> z = zipper_of_list [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]

<span class="kw">let</span> twice_forward_once_backward_and_set =
  z
  |&gt; forward
  |&gt; and_then forward
  |&gt; and_then backward
  |&gt; and_then (set <span class="dv">5</span>)
<span class="co">(* z remains unchanged *)</span>
<span class="co">(* twice_forward_once_backward_and_set is now [1; 5; 3; 4] *)</span></code></pre></div>
<p>If this was instead performed on a normal cons-nil list, you would only be able to get fast updates on the next cons cell (instead of the currently focused one), or you would have to traverse up till the cell before the current.</p>
<p>The examples in this post have are available <a href="https://github.com/ngzhian/zippers">here</a>. You can also find a experimental implementation of a tree with zipper in the repository.</p>
<h2 id="references">References</h2>
<p><a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)" class="uri">https://en.wikipedia.org/wiki/Zipper_(data_structure)</a></p>
<p><a href="http://learnyouahaskell.com/zippers" class="uri">http://learnyouahaskell.com/zippers</a></p>
<p><a href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip1/" class="uri">http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip1/</a></p>
<p><a href="http://okmij.org/ftp/continuations/zipper.html" class="uri">http://okmij.org/ftp/continuations/zipper.html</a></p>
</section>
</body>
</html>
