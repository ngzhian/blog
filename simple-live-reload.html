<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="author" content="Ng Zhi An">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,700" type="text/css">
  <meta name="generator" content="pandoc" />
  <meta name="date" content="2020-07-12" />
  <title>Creating a simple live reload server for my blog</title>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body>
<section class="content">
<a class="home" href="./index.html">Home</a>
<div id="header">
<h1 class="title">Creating a simple live reload server for my blog</h1>
<p class="published">2020-07-12</p>
</div>
<p>This post describes how I added a hot-reload feature to my blogging workflow.</p>
<p>This blog is made up of</p>
<ul>
<li>Markdown files in a “posts/” directory,</li>
<li>compiled to individual HTML files by Pandoc with a custom template,</li>
<li>and an index page generated by a shell script (awk and sed).</li>
</ul>
<p>Commands to build and deploy is codified in a Makefile:</p>
<ul>
<li><code>make</code> to build everything</li>
<li><code>make deploy</code> to deploy</li>
<li><code>make watch</code> to watch for file changes and do a make (this was a <a href="https://github.com/ngzhian/blog/commit/3c1a7d086ccf5082cf877f954077f74cfe59faaa">new feature added recently</a>)</li>
</ul>
<p>This workflow has been working well, but I felt that things can be improved by adding some sort of <a href="https://markdownlivepreview.com/">live preview</a>. I would like to be able to open my Markdown files alongside the HTML page, edit my post, and see changes live.</p>
<h2 id="hot-reload">Hot reload</h2>
<p>The simplest way would be to insert some sort of JS that does a page refresh every 5s. It might seem sort of a waste, but it will work. The problem is that 5s might be too long - Pandoc compilation takes much less than 1s, and it would take less than 5s for me to manually refresh.</p>
<p>So instead, we need a way for a local server to inform the webpage that something changed, and should be reloaded.</p>
<p>This is a very common feature present in many development environments, <a href="https://flutter.dev/docs/development/tools/hot-reload">Flutter</a>, <a href="https://reactnative.dev/blog/2016/03/24/introducing-hot-reloading.html">React Native</a>, and many JS front-end environments. This usually goes by the name <em>hot reload</em>. Note that these are much more complicated, in that they hot-swap specific parts (components) that changed, without reloading the entire page. For my blog, reloading the entire page is <em>just fine</em>.</p>
<h1 id="websockets">WebSockets</h1>
<p>For this, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>. We will need:</p>
<ul>
<li>a local server that understands WebSocket</li>
<li>some small JS snippet that will be included in a webpage</li>
<li>this JS snippet will establish a connection with the server</li>
<li>when files are modified locally, the local server will inform the web page via this connection</li>
</ul>
<p>I chose to use <a href="https://github.com/uNetworking/uWebSockets">uWebSockets</a> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, which has an example <a href="https://github.com/uNetworking/uWebSockets/blob/master/examples/EchoServer.cpp">EchoServer</a> built in - all it does is echo whatever the client sent:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># make sure to do recursive, it has a submodule which you need to pull in</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">git</span> clone --recursive git@github.com:uNetworking/uWebSockets.git</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">make</span> examples</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ex">./EchoServer</span></span></code></pre></div>
<p>With the server up at “localhost:9001”, we now need a client to do a test. I wrote up a simple HTML page, following instructions on MDN’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications">Writing WebSocket client applications</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">&lt;html&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">&lt;head&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="kw">&lt;script&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>      <span class="kw">var</span> s <span class="op">=</span> <span class="kw">new</span> <span class="bu">WebSocket</span>(<span class="st">&quot;ws://localhost:9001&quot;</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>      s<span class="op">.</span><span class="at">onopen</span> <span class="op">=</span> <span class="kw">function</span>(<span class="bu">event</span>) {</span>
<span id="cb2-6"><a href="#cb2-6"></a>        s<span class="op">.</span><span class="fu">send</span>(<span class="st">&quot;Hello world!&quot;</span>)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>      }</span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">&lt;/script&gt;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="kw">&lt;/head&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">&lt;/html&gt;</span></span></code></pre></div>
<p>The important part here is to call <code>s.send</code> inside the callback <code>s.onopen</code>, since establishing a WebSocket connection is asynchronous. I missed that initially and got no response from the server.</p>
<p>You should then be able to see “Hello world!” sent from the page to the server, and back <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<h2 id="listening-to-file-changes">Listening to file changes</h2>
<p>We can now communicate from the server to our webpage, but the echo server can only do so via a message from the client (hence echo). What we need to do now is to change our Make+Pandoc build to notify the WebSocket server that it should send a message to the client.</p>
<p>There are many ways to do this. While browsing the examples in uWebSockets, I found <code>misc/main.cpp</code>, which showed how you can define HTTP endpoints <em>and</em> WebSocket endpoints listening on the same port. This makes sense, because a WebSocket connection always starts with a HTTP connection with special headers, and then that get upgraded into a WebSocket connection.</p>
<p>So that’s what we will use:</p>
<ul>
<li>when Pandoc is done building HTML, curl localhost:9001</li>
<li>set up the local server to listen on 9001 for a HTTP request (without the upgrade headers)</li>
<li>send a message to connected WebSocket clients (that’s the web page)</li>
<li>have the JS snippet listen to this message, and refresh the page</li>
</ul>
<p>The tricky part is here to store the WebSocket object in the server. For simplicity, I chose a single global pointer (not exactly global, since it’s still within <code>main</code>, but funtions as a global). This means that I can only have a single active WebSocket connection that I can ask to refresh the page, but is fine for my use case now.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">int</span> main() {</span>
<span id="cb3-2"><a href="#cb3-2"></a>  uWS::WebSocket&lt;<span class="kw">false</span>, <span class="kw">true</span>&gt; *global_ws = <span class="kw">nullptr</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>  uWS::App()</span>
<span id="cb3-5"><a href="#cb3-5"></a>    .get(<span class="st">&quot;/&quot;</span>, [&amp;global_ws](<span class="kw">auto</span> *res, <span class="kw">auto</span> *req) {</span>
<span id="cb3-6"><a href="#cb3-6"></a>        <span class="cf">if</span> (global_ws != <span class="kw">nullptr</span>) {</span>
<span id="cb3-7"><a href="#cb3-7"></a>          global_ws-&gt;send(<span class="st">&quot;refresh&quot;</span>, uWS::OpCode::TEXT);</span>
<span id="cb3-8"><a href="#cb3-8"></a>        }</span>
<span id="cb3-9"><a href="#cb3-9"></a>        res-&gt;end(<span class="st">&quot;&quot;</span>);</span>
<span id="cb3-10"><a href="#cb3-10"></a>    })</span>
<span id="cb3-11"><a href="#cb3-11"></a>    .ws&lt;PerSocketData&gt;(<span class="st">&quot;/*&quot;</span>, {</span>
<span id="cb3-12"><a href="#cb3-12"></a>      <span class="co">// more configuration</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>      .open = [&amp;global_ws](<span class="kw">auto</span> *ws) {</span>
<span id="cb3-14"><a href="#cb3-14"></a>        <span class="co">/* Open event here, you may access ws-&gt;getUserData() which points to a PerSocketData struct */</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>        global_ws = ws;</span>
<span id="cb3-16"><a href="#cb3-16"></a>      },</span>
<span id="cb3-17"><a href="#cb3-17"></a>      .close = [&amp;global_ws](<span class="kw">auto</span> *ws, <span class="dt">int</span> code, <span class="bu">std::</span>string_view message) {</span>
<span id="cb3-18"><a href="#cb3-18"></a>          global_ws = <span class="kw">nullptr</span>;</span>
<span id="cb3-19"><a href="#cb3-19"></a>      }</span>
<span id="cb3-20"><a href="#cb3-20"></a>    }).listen(<span class="dv">9001</span>, [](<span class="kw">auto</span> *token) {</span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="cf">if</span> (token) {</span>
<span id="cb3-22"><a href="#cb3-22"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Listening on port &quot;</span> &lt;&lt; <span class="dv">9001</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb3-23"><a href="#cb3-23"></a>        }</span>
<span id="cb3-24"><a href="#cb3-24"></a>    }).run();</span>
<span id="cb3-25"><a href="#cb3-25"></a>}</span></code></pre></div>
<p>The second part is that I wouldn’t want this JS snippet to be in my final HTML that goes live, only for development. So I will need to have a separate template that Pandoc uses for local builds. That’s not too hard, just a bit of duplication. I chose to create a separate “dev” directory and will recompile all my posts, then add “dev” to .gitignore.</p>
<h2 id="keepalive">Keepalive</h2>
<p>Aka “why does my websocket connection close automatically?” (because I literally Googled this). This is a somewhat nasty problem I faced before, while working on a school project that <a href="/chrome-offline-network-emulation-websocket.html">used WebSockets to build a chat application</a>.</p>
<p>Browsers will terminate WebSocket connections after a period of inactivity (probably to save resources). So, I was seeing my hotreload work for a couple of saves, then it stopped working. The fix here is to register a function using <code>setInterval</code> to send <em>keepalive</em> messages to the server every 5 seconds:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">var</span> intervalId<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">// Ping every 5s to keep this WS connection alive.</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">// Otherwise the browser will terminate this connection.</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">function</span> <span class="fu">keepalive</span>(s) {</span>
<span id="cb4-6"><a href="#cb4-6"></a>  intervalId <span class="op">=</span> <span class="pp">setInterval</span>(<span class="kw">function</span>() {</span>
<span id="cb4-7"><a href="#cb4-7"></a>    s<span class="op">.</span><span class="fu">send</span>(<span class="st">&quot;keepalive&quot;</span>)<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>  }<span class="op">,</span> <span class="dv">5000</span>)<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>}</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="kw">var</span> s <span class="op">=</span> <span class="kw">new</span> <span class="bu">WebSocket</span>(<span class="st">&quot;ws://localhost:9001&quot;</span>)<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>s<span class="op">.</span><span class="at">onopen</span> <span class="op">=</span> <span class="kw">function</span>(even) {</span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;WebSocket connection open.&quot;</span>)<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>  keepalive(s)<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>}<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>s<span class="op">.</span><span class="at">onclose</span> <span class="op">=</span> <span class="kw">function</span>(even) {</span>
<span id="cb4-17"><a href="#cb4-17"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;WebSocket connection closed.&quot;</span>)<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>  <span class="pp">clearInterval</span>(intervalId)<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19"></a>}<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>s<span class="op">.</span><span class="at">onerror</span> <span class="op">=</span> <span class="kw">function</span>(<span class="bu">event</span>) {</span>
<span id="cb4-21"><a href="#cb4-21"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;WebSocket error observed:&quot;</span><span class="op">,</span> <span class="bu">event</span>)<span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>  <span class="pp">clearInterval</span>(intervalId)<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>}<span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>s<span class="op">.</span><span class="at">onmessage</span> <span class="op">=</span> <span class="kw">function</span>(<span class="bu">event</span>) {</span>
<span id="cb4-25"><a href="#cb4-25"></a>  <span class="cf">if</span> (<span class="bu">event</span><span class="op">.</span><span class="at">data</span> <span class="op">===</span> <span class="st">&quot;refresh&quot;</span>) {</span>
<span id="cb4-26"><a href="#cb4-26"></a>    location<span class="op">.</span><span class="fu">reload</span>()<span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>  }</span>
<span id="cb4-28"><a href="#cb4-28"></a>}<span class="op">;</span></span></code></pre></div>
<p>Clearing <code>intervalId</code> is not required for this small project, but is good habit anyway.</p>
<h2 id="stopping-the-hotreload-server">Stopping the hotreload server</h2>
<p>The problem with the current setup is that, I’m starting the server as a backgrounded task, which means that when I Ctrl-C on my terminal, it is left in the background.</p>
<p>It is not a huge deal, since when I terminate the shell session it goes away, but it is a bit annoying.</p>
<p>I remember reading about <code>trap</code> in bash, which is a way to catch signals and respond to it. I found a <a href="https://www.linuxjournal.com/content/bash-trap-command">useful guide</a>, which suggests using a special <code>EXIT</code> signal that can be use to do some cleanup right before a bash script exits.</p>
<p>So the simple fix is to create a helper script that:</p>
<ul>
<li>sets a trap on <code>EXIT</code>,</li>
<li>runs <code>hotreload</code> and backgrounds it,</li>
<li>set up fswatch to automatically build changed pages,</li>
<li>when I hit <code>Ctrl-C</code> on the terminal, it stops the script, and is caught by the trap, and kills the backgrounded <code>hotreload</code>.</li>
</ul>
<p>You can see the changes on <a href="https://github.com/ngzhian/blog">Github</a>. “hotreload.cpp” is the server, lightly modified from the example “EchoServer”. The Makefile contains some hardcoded paths to the headers and object files for uWebSockets, so if you want to use it, you’ll need to modify it.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I’ve been doing C++ development recently, and wanted to expose myself to more C++ projects.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>You can observe WebSocket messages in the <a href="https://developers.google.com/web/updates/2019/03/devtools#binary">Chrome DevTools</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</section>
</body>
</html>
